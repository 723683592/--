<!DOCTYPE html>
<html lang ="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  /*将最小值的搜索的时间复杂度降到常数级别*/
  /*
  取最小值：创造递减栈，由于整个栈，由栈底到栈顶递减，所以栈顶就是最小值
  若有新元素入栈：判断是不是比栈顶元素还要小，否则不准进入satck2
  若有元素出栈：判断是不是和栈顶元素相等，如果是的话，stack2也要出栈
  */
  <script>
    // 构造函数，存储结构的初始化
    function MinStack() {
      this.stack1 = []
      this.stack2 = []
    }
    MinStack.prototype.push = function (el) {
      this.stack1.push(el)
      if (this.stack2.length == 0 || el < this.stack2[this.stack2.length - 1]) {
        this.stack2.push(el)
      }
    }
    MinStack.prototype.pop = function () {
      const top = this.stack1.pop()
      if (top == this.stack2[this.stack2.length - 1]) {
        this.stack2.pop()
      }
    }
    MinStack.prototype.top = function () {
      if (this.stack1.length == 0) {
        return null
      }
      return this.stack1[this.stack1.length - 1]
    }
    // 按照一次遍历的思路取最小值,此时时间复杂度是n
    // 但是不够酷，应该有更骚的解法
    MinStack.prototype.getMin = function () {
      return this.stack2[this.stack2.length - 1]
    }
  </script>
</body>

</html>